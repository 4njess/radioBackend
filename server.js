//server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const dotenv = require("dotenv");
const { v4: uuidv4 } = require("uuid");
const axios = require("axios");
const pool = require("./db.js");
const NodeCache = require("node-cache");
const stateCache = new NodeCache({ stdTTL: 0, checkperiod: 0 });

dotenv.config();
const app = express();
const server = http.createServer(app);

// –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã
const allowedOrigins = [
    "https://radioinear.vercel.app",
    "http://localhost:3000",
    "https://radioclient-gacetihnu-linear-80e9e17cvercel.app",
    "https://radiobackend-iss7.onrender.com",
];

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
app.use((req, res, next) => {
    console.log(
        `[${new Date().toISOString()}] ${req.method} ${req.url} | Origin: ${
            req.headers.origin
        }`
    );
    next();
});

// –û—Å–Ω–æ–≤–Ω–æ–π CORS middleware
app.use((req, res, next) => {
    const origin = req.headers.origin;

    if (allowedOrigins.includes(origin)) {
        res.setHeader("Access-Control-Allow-Origin", origin);
        res.setHeader(
            "Access-Control-Allow-Methods",
            "GET, POST, PUT, DELETE, OPTIONS"
        );
        res.setHeader(
            "Access-Control-Allow-Headers",
            "Content-Type, Authorization, Range"
        );
        res.setHeader(
            "Access-Control-Expose-Headers",
            "Content-Length, Content-Range"
        );
        res.setHeader("Access-Control-Allow-Credentials", "true");
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ preflight –∑–∞–ø—Ä–æ—Å–æ–≤
    if (req.method === "OPTIONS") {
        return res.sendStatus(204);
    }

    next();
});

// –¢–µ—Å—Ç–æ–≤—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
app.get("/", (req, res) => {
    res.send("üéß –†–∞–¥–∏–æ-—Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç");
});

app.get("/api/ping", (req, res) => {
    res.json({
        status: "ok",
        time: new Date(),
        environment: process.env.NODE_ENV,
        node: process.version,
    });
});

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Socket.IO
const io = new Server(server, {
    cors: {
        origin: allowedOrigins,
        methods: ["GET", "POST"],
        credentials: true,
    },
    transports: ["websocket"],
});

app.use(express.json());
app.use("/api", require("./routes/apiRoute.js"));

app.get("/health/routes", (req, res) => {
    const routes = [];
    app._router.stack.forEach((middleware) => {
        if (middleware.route) {
            // –ø—Ä—è–º—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã (route)
            const methods = Object.keys(middleware.route.methods)
                .map((m) => m.toUpperCase())
                .join(",");
            routes.push(`${methods} ${middleware.route.path}`);
        } else if (middleware.name === "router") {
            // –º–∞—Ä—à—Ä—É—Ç—ã –≤–Ω—É—Ç—Ä–∏ —Ä–æ—É—Ç–µ—Ä–æ–≤
            middleware.handle.stack.forEach((handler) => {
                const route = handler.route;
                if (route) {
                    const methods = Object.keys(route.methods)
                        .map((m) => m.toUpperCase())
                        .join(",");
                    routes.push(`${methods} /api${route.path}`);
                }
            });
        }
    });
    res.json({ routes });
});

let pendingRequests = [];
global.userNotifications = [];

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö
const queues = {
    rock: { youtube: [], rutube: [] },
    hiphop: { youtube: [], rutube: [] },
    electronic: { youtube: [], rutube: [] },
};

const timers = {
    rock: { youtube: null, rutube: null },
    hiphop: { youtube: null, rutube: null },
    electronic: { youtube: null, rutube: null },
};

const currentTracks = {
    rock: { youtube: null, rutube: null },
    hiphop: { youtube: null, rutube: null },
    electronic: { youtube: null, rutube: null },
};

const currentPlatforms = {
    rock: "youtube",
    hiphop: "youtube",
    electronic: "youtube",
};

function parseISODuration(d) {
    const m = d.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    return (+m[1] || 0) * 3600 + (+m[2] || 0) * 60 + (+m[3] || 0);
}

function isTrackPlaying(t) {
    if (!t) return false;
    return (Date.now() - t.startedAt) / 1000 < t.durationSec;
}

// function startNextTrack(genre, platform) {
//     const queueForPlatform = queues[genre][platform];

//     if (queueForPlatform.length === 0) {
//         currentTracks[genre][platform] = null;
//         io.emit(`now-playing-${genre}-${platform}`, null);
//         return;
//     }

//     const next = queueForPlatform.shift();
//     currentTracks[genre][platform] = { ...next, startedAt: Date.now() };

//     io.emit(`queue-update-${genre}-${platform}`, queueForPlatform);
//     io.emit(`now-playing-${genre}-${platform}`, currentTracks[genre][platform]);

//     setTimeout(() => startNextTrack(genre, platform), next.durationSec * 1000);
// }

// –û–±–Ω–æ–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é startNextTrack
// function startNextTrack(genre, platform) {
//     if (timers[genre][platform]) {
//         clearTimeout(timers[genre][platform]);
//         timers[genre][platform] = null;
//     }

//     const queueForPlatform = queues[genre][platform];

//     if (queueForPlatform.length === 0) {
//         currentTracks[genre][platform] = null;
//         io.emit(`now-playing-${genre}-${platform}`, null);
//         return;
//     }

//     const next = queueForPlatform.shift();
//     const now = Date.now();

//     // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å
//     const prevTrack = currentTracks[genre][platform];
//     let startOffset = 0;

//     if (prevTrack) {
//         const elapsed = (now - prevTrack.startedAt) / 1000;
//         if (elapsed < prevTrack.durationSec) {
//             startOffset = elapsed;
//         }
//     }

//     currentTracks[genre][platform] = {
//         ...next,
//         startedAt: now - startOffset * 1000
//     };

//     io.emit(`queue-update-${genre}-${platform}`, queueForPlatform);
//     io.emit(`now-playing-${genre}-${platform}`, currentTracks[genre][platform]);

//     const remainingTime = next.durationSec * 1000 - startOffset * 1000;

//     timers[genre][platform] = setTimeout(
//         () => startNextTrack(genre, platform),
//         remainingTime
//     );
// }

function startNextTrack(genre, platform) {
    if (timers[genre][platform]) {
        clearTimeout(timers[genre][platform]);
        timers[genre][platform] = null;
    }

    const queueForPlatform = queues[genre][platform];

    if (queueForPlatform.length === 0) {
        currentTracks[genre][platform] = null;
        io.emit(`now-playing-${genre}-${platform}`, null);
        return;
    }
    const next = queueForPlatform.shift();

    const now = Date.now();
    currentTracks[genre][platform] = {
        ...next,
        startedAt: now,
    };

    // —Å—Ä–∞–∑—É –∂–µ –æ—Ç–¥–∞–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—É—é –æ—á–µ—Ä–µ–¥—å
    io.emit(`queue-update-${genre}-${platform}`, queueForPlatform);
    // –∏ —Ç–µ–∫—É—â–∏–π —Ç—Ä–µ–∫
    io.emit(`now-playing-${genre}-${platform}`, currentTracks[genre][platform]);

    // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —á—Ç–æ–±—ã –ø—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–µ —Å—Ç–∞—Ä—ã–π —Ç—Ä–µ–∫ –Ω–µ ¬´–≤–µ—Ä–Ω—É–ª—Å—è¬ª
    saveServerState();

    // –ø–ª–∞–Ω–∏—Ä—É–µ–º –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π
    timers[genre][platform] = setTimeout(() => {
        // –ø–æ—Å–ª–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø—É—Å—Ç–∏–º —Å–ª–µ–¥—É—é—â–∏–π
        startNextTrack(genre, platform);
    }, next.durationSec * 1000);
}

// –§—É–Ω–∫—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
function saveServerState() {
    const state = {
        queues,
        currentTracks,
        currentPlatforms,
        pendingRequests,
    };
    stateCache.set("serverState", state);
}

// –§—É–Ω–∫—Ü–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
function loadServerState() {
    const savedState = stateCache.get("serverState");
    if (savedState) {
        Object.assign(queues, savedState.queues);
        Object.assign(currentTracks, savedState.currentTracks);
        Object.assign(currentPlatforms, savedState.currentPlatforms);
        pendingRequests = savedState.pendingRequests;

        // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä—ã
        for (const genre of Object.keys(currentTracks)) {
            for (const platform of ["youtube", "rutube"]) {
                const track = currentTracks[genre][platform];
                if (track && track.startedAt) {
                    const elapsed = (Date.now() - track.startedAt) / 1000;
                    const remaining = track.durationSec - elapsed;
                    if (remaining > 0) {
                        if (timers[genre][platform]) {
                            clearTimeout(timers[genre][platform]);
                        }

                        timers[genre][platform] = setTimeout(
                            () => startNextTrack(genre, platform),
                            remaining * 1000
                        );
                    } else {
                        startNextTrack(genre, platform);
                    }
                }
            }
        }
    }
}

io.on("connection", (socket) => {
    console.log("üîå –ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç");
    loadServerState();

    const saveState = () => {
        saveServerState();
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–æ–≤–æ–º—É –∫–ª–∏–µ–Ω—Ç—É
        for (const genre of Object.keys(currentTracks)) {
            for (const platform of ["youtube", "rutube"]) {
                socket.emit(
                    `queue-update-${genre}-${platform}`,
                    queues[genre][platform]
                );
                socket.emit(
                    `now-playing-${genre}-${platform}`,
                    currentTracks[genre][platform]
                );
            }
        }
    };

    socket.on("get-moderation-queue", async () => {
        // –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º –≤—Å–µ –∑–∞—è–≤–∫–∏ —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º "sent"
        const { rows } = await pool.query(
            `SELECT id, genre, track, username, message, title, user_id AS "userId", platform
                FROM requests
                WHERE status = 'sent'
                ORDER BY timestamp`
        );
        // —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –ø–∞–º—è—Ç—å
        pendingRequests = rows;
        socket.emit("moderation-queue", rows);
    });

    socket.on("register-user", (userId) => {
        if (userId) socket.join(userId);
    });

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
    for (const genre of Object.keys(currentTracks)) {
        for (const platform of ["youtube", "rutube"]) {
            socket.emit(
                `now-playing-${genre}-${platform}`,
                currentTracks[genre][platform]
            );
            socket.emit(
                `queue-update-${genre}-${platform}`,
                queues[genre][platform]
            );
        }
    }
    socket.emit("moderation-queue", pendingRequests);

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–ø—Ä–æ—Å–∞ –æ—á–µ—Ä–µ–¥–∏
    socket.on("get-queue", ({ genre, platform }) => {
        socket.emit(
            `queue-update-${genre}-${platform}`,
            queues[genre][platform]
        );

        const cur = currentTracks[genre][platform];
        if (isTrackPlaying(cur)) {
            socket.emit(`now-playing-${genre}-${platform}`, cur);
        } else if (queues[genre][platform].length) {
            startNextTrack(genre, platform);
        } else {
            socket.emit(`now-playing-${genre}-${platform}`, null);
        }
    });

    socket.on("change-platform", ({ genre, platform }) => {
        saveState();

        const prevPlatform = currentPlatforms[genre];

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
        if (timers[genre][prevPlatform]) {
            clearTimeout(timers[genre][prevPlatform]);
            timers[genre][prevPlatform] = null;
        }

        // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—É
        currentPlatforms[genre] = platform;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –Ω–æ–≤–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
        const currentTrack = currentTracks[genre][platform];
        const queue = queues[genre][platform];

        // –ï—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π —Ç—Ä–µ–∫ - –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
        if (currentTrack && isTrackPlaying(currentTrack)) {
            const elapsed = (Date.now() - currentTrack.startedAt) / 1000;
            const remaining = currentTrack.durationSec - elapsed;

            if (remaining > 0) {
                timers[genre][platform] = setTimeout(
                    () => startNextTrack(genre, platform),
                    remaining * 1000
                );
            } else {
                startNextTrack(genre, platform);
            }
        }
        // –ï—Å–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞, –Ω–æ –µ—Å—Ç—å –æ—á–µ—Ä–µ–¥—å - –∑–∞–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π
        else if (queue.length > 0) {
            startNextTrack(genre, platform);
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        io.emit(
            `now-playing-${genre}-${platform}`,
            currentTracks[genre][platform]
        );
        io.emit(`queue-update-${genre}-${platform}`, queue);
    });

    socket.on("new-request", async ({ genre, request, platform }) => {
        const id = uuidv4();
        const timestamp = new Date();

        // 1. –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –ø–∞–º—è—Ç—å
        pendingRequests.push({
            ...request,
            id,
            genre,
            platform,
            status: "sent",
            timestamp,
        });

        // 2. –°—Ä–∞–∑—É —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        await pool.query(
            `INSERT INTO requests
        (id, genre, track, username, message, title, status, timestamp, user_id, platform)
        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)`,
            [
                id,
                genre,
                request.track,
                request.username,
                request.message,
                request.title,
                "sent",
                timestamp,
                request.userId,
                platform,
            ]
        );

        // 3. –†–∞—Å—Å—ã–ª–∞–µ–º –≤—Å–µ–º –∞–¥–º–∏–Ω–∞–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –ø—É–ª
        io.emit("moderation-queue", pendingRequests);

        // 4. –û–ø–æ–≤–µ—â–µ–Ω–∏–µ –ø—Ä–æ cooldown
        io.emit(`cooldown-update-${genre}`, {
            userId: request.userId,
            genre,
            until: Date.now() + 60 * 1000,
        });
    });

    socket.on("sync-platform", ({ genre, platform }) => {
        const currentTrack = currentTracks[genre][platform];

        // –ï—Å–ª–∏ —Ç—Ä–µ–∫ –∏–≥—Ä–∞–µ—Ç - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if (currentTrack && isTrackPlaying(currentTrack)) {
            socket.emit(`now-playing-${genre}-${platform}`, currentTrack);
        }
        // –ò–Ω–∞—á–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º null
        else {
            socket.emit(`now-playing-${genre}-${platform}`, null);
        }

        // –í—Å–µ–≥–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—É—é –æ—á–µ—Ä–µ–¥—å
        socket.emit(
            `queue-update-${genre}-${platform}`,
            queues[genre][platform]
        );
    });

    socket.on("moderate-request", async ({ id, action, reason }) => {
        saveState();
        const idx = pendingRequests.findIndex((r) => r.id === id);
        if (idx === -1) return;
        const reqObj = pendingRequests.splice(idx, 1)[0];
        const { genre, track, username, message, title, userId, platform } =
            reqObj;

        if (action === "approve") {
            let durationSec = 180;
            if (platform === "youtube") {
                try {
                    const vidId = new URL(track).searchParams.get("v");
                    const resp = await axios.get(
                        "https://www.googleapis.com/youtube/v3/videos",
                        {
                            params: {
                                key: process.env.YOUTUBE_API_KEY,
                                id: vidId,
                                part: "contentDetails",
                            },
                        }
                    );
                    const iso = resp.data.items?.[0]?.contentDetails?.duration;
                    durationSec = parseISODuration(iso) || durationSec;
                } catch (e) {
                    console.warn(
                        "YouTube duration fetch failed, using default"
                    );
                }
            }
            if (platform === "rutube") {
                try {
                    // 1) –ü–æ–ª—É—á–∞–µ–º rutId
                    const parsed = new URL(track);
                    const segments = parsed.pathname.split("/").filter(Boolean);
                    const rutId = segments[segments.length - 1];
                    if (!rutId) throw new Error("Invalid RuTube ID");

                    // 2) –ë–µ—Ä—ë–º master-playlist URL
                    const optsRes = await axios.get(
                        `https://rutube.ru/api/play/options/${rutId}/`,
                        {
                            headers: {
                                Referer: `https://rutube.ru/video/${rutId}/`,
                                Origin: "https://rutube.ru",
                            },
                        }
                    );
                    const masterUrl = optsRes.data.video_balancer?.m3u8;
                    if (!masterUrl) throw new Error("No m3u8 URL");

                    // 3) –°–∫–∞—á–∏–≤–∞–µ–º master-playlist
                    const masterRes = await axios.get(masterUrl, {
                        responseType: "text",
                    });
                    const lines = masterRes.data.split("\n");

                    // 4) –ò—â–µ–º –ø–µ—Ä–≤—É—é variant
                    let variantLine;
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].startsWith("#EXT-X-STREAM-INF:")) {
                            variantLine = lines[i + 1];
                            break;
                        }
                    }
                    if (!variantLine) throw new Error("No variant found");

                    // 5) –§–æ—Ä–º–∏—Ä—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π URL variant
                    const masterBase = new URL(masterUrl);
                    const variantUrl = new URL(variantLine, masterBase).href;

                    console.log("Using variant playlist:", variantUrl);

                    // 6) –°–∫–∞—á–∏–≤–∞–µ–º variant-playlist –∏ –ø–∞—Ä—Å–∏–º #EXTINF
                    const variantRes = await axios.get(variantUrl, {
                        responseType: "text",
                    });
                    const parsedDuration = variantRes.data
                        .split("\n")
                        .filter((l) => l.startsWith("#EXTINF:"))
                        .map((l) => parseFloat(l.slice(8).split(",")[0]))
                        .reduce((sum, seg) => sum + seg, 0);

                    if (!parsedDuration || isNaN(parsedDuration)) {
                        console.warn("EXTINF parse failed, fallback 180s");
                        durationSec = 180;
                    } else {
                        durationSec = Math.floor(parsedDuration);
                        console.log(`Parsed RuTube duration: ${durationSec}s`);
                    }
                } catch (err) {
                    console.warn(
                        "–û—à–∏–±–∫–∞ –ø–æ–¥—Å—á—ë—Ç–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ RuTube, fallback 180s",
                        err.message
                    );
                    durationSec = 180;
                }
            }

            durationSec = durationSec || 180;

            const enriched = { ...reqObj, durationSec };

            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            queues[genre][platform].push(enriched);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
            await pool.query(
                `INSERT INTO requests
        (id, genre, track, username, message, title, status,
        duration_sec, timestamp, started_at, user_id, platform)
        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)`,
                [
                    enriched.id,
                    genre,
                    track,
                    username,
                    message,
                    title,
                    "approved",
                    enriched.durationSec,
                    new Date(),
                    new Date(),
                    userId,
                    platform,
                ]
            );

            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—á–µ—Ä–µ–¥—å
            io.emit(
                `queue-update-${genre}-${platform}`,
                queues[genre][platform]
            );

            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç—Ä–µ–∫, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç
            if (!isTrackPlaying(currentTracks[genre][platform])) {
                startNextTrack(genre, platform);
            }

            // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            const notif = {
                userId,
                message: `–í–∞—à–∞ –∑–∞—è–≤–∫–∞ "${title}" –æ–¥–æ–±—Ä–µ–Ω–∞ ‚úÖ`,
                type: "success",
                read: false,
            };
            global.userNotifications.push(notif);
            io.to(userId).emit("new-notification", notif);
        }

        if (action === "reject") {
            const notif = {
                userId,
                message: `–ó–∞—è–≤–∫–∞ "${title}" –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ ‚ùå –ü—Ä–∏—á–∏–Ω–∞: ${reason}`,
                type: "error",
                read: false,
            };
            global.userNotifications.push(notif);
            io.to(userId).emit("new-notification", notif);
        }

        await pool.query(`UPDATE requests SET status = $1 WHERE id = $2`, [
            action === "approve" ? "approved" : "rejected",
            id,
        ]);

        const { rows: updated } = await pool.query(
            `SELECT id, genre, track, username, message, title, user_id AS "userId", platform
                FROM requests
                WHERE status = 'sent'
                ORDER BY timestamp`
        );

        pendingRequests = updated;
        io.emit("moderation-queue", updated);
    });

    socket.on("disconnect", () => console.log("‚ùå –ö–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á—ë–Ω"));
});

const PORT = process.env.PORT || 10000;
server.listen(PORT, () => {
    console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
    console.log("–†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã:", allowedOrigins);
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫
process.on("uncaughtException", (err) => {
    console.error("–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞:", err);
});

process.on("unhandledRejection", (reason, promise) => {
    console.error("–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π rejection:", promise, "–ø—Ä–∏—á–∏–Ω–∞:", reason);
});
